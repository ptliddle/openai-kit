//
//  ToolTests.swift.swift
//  openai-kit
//
//  Created by Peter Liddle on 11/21/25.
//

import XCTest
import OpenAIKit

// Mock codable object for defining a schema in testing, doesn't encode correctly
enum CodableValue: Codable {
    case string(String)
    case array([CodableValue])
    case map([String: CodableValue])
    case bool(Bool)
    
    
    func encode(to encoder: any Encoder) throws {
        var container = encoder.singleValueContainer()
        
        switch self {
        case .string(let string):
            try container.encode(string)
        case .array(let array):
            try container.encode(array)
        case .map(let map):
            try container.encode(map)
        case .bool(let bool):
            try container.encode(bool)
        }
    }
}

final class ToolTests_swift: XCTestCase {


    
#if USE_NIO
    private var client: Client!
    private var httpClient: HTTPClient!
    
    override func setUpWithError() throws {
        
        let eventLoopGroup = MultiThreadedEventLoopGroup(numberOfThreads: 1)

        httpClient = HTTPClient(eventLoopGroupProvider: .shared(eventLoopGroup))
        
        let configuration = Configuration(apiKey: "YOUR-API-KEY")
        
        client = Client(
            httpClient: httpClient,
            configuration: configuration
        )
    }
    
    override func tearDownWithError() throws {
        try httpClient.syncShutdown()
    }
#else
    private var client: Client!
    var tool: Tool!
    
    override func setUpWithError() throws {
        guard let apiKey = ProcessInfo.processInfo.environment["OPENAI_API_KEY"] else {
            fatalError("API required to perform tests")
        }
        let configuration = Configuration(apiKey: apiKey) //"YOUR-API-KEY")
        let urlSession = URLSession(configuration: .default)
        client = Client(session: urlSession, configuration: configuration)
        
        tool = Tool(type: .function, name: "getWeather", description: "A tool that returns the weather", parameters: ErasedCodable(with: testFunctionSchema)) //["param1": "value"]
    }
    
    override func tearDownWithError() throws {
        client = nil
    }
    
#endif
    
    let testFunctionSchema: [String: CodableValue] = [
        "type": .string("object"),
        "properties": .map([
            "location": .map([
                "type": .string("string"),
                "description": .string("City and country e.g. Bogot√°, Colombia")
            ]),
            "units": .map([
                "type": .string("string"),
                "enum": .array([.string("celsius"), .string("fahrenheit")]),
                "description": .string("Units the temperature will be returned in.")
            ]),
        ]),
        "required": .array([.string("location"), .string("units")]),
        "additionalProperties": .bool(false)
    ]
    
    
   

    func test_encodeToolDefinition() throws {

        let jsonEncoder = JSONEncoder()
        let data = try jsonEncoder.encode(tool)
        
        let json = try TestHelpers.prettyPrintJSON(from: data)

        print(json)
    }

//    response = client.responses.create(
//        model="gpt-5",
//        instructions="Respond only with a horoscope generated by a tool.",
//        tools=tools,
//        input=input_list,
//    )
//    
    func test_createToolCallChat() async throws {
        let messages: [InputItem] = [
            .message(.init(role: .system, content: [.inputText("You are a weather forecaster with the following tool available to help")])),
            .message(.init(role: .user, content: [.inputText("What is the weather in Phoenix, AZ USA today in celsius?")]))
        ]

        let completion = try await client.responses.create(
            model: Model.GPT4.gpt4_1,
            messages: messages,
            tools: [tool],
            reasoningEffort: nil)
        
        print(completion)
        
        
        
        if let arg1 = completion.output.first?.arguments, let data = arg1.data(using: String.Encoding.utf8) {
            let arguments = try JSONDecoder().decode([String: String].self, from: data)
            print(arguments)
        }
    }
    
}
